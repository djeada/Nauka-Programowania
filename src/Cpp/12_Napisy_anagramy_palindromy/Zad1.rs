 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 
/** Crust doesn't resolve C/C++ dependencies or included header.
* You may have to define your own module and implement those functionality in Rust 
* Or you can translate header file with Crust to produce Rust code. * 
* >>>>>>>> # include < algorithm >
 * >>>>>>>> # include < cassert >
 * >>>>>>>> # include < string >
 **/
 // Sprawdz czy slowo jest palindromem.
 fn palindrom ( string : std ) -> bool { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut N : i32 = slowo.length()-1; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut i : i32 = 0; ; while i <= N / 2 { if ( slowo [ i ] != slowo [ N - i ] ) == true { 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 false } i +=1 ; } 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 true } fn test1 ( ) { std :: 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut slowo : String = "kajak"; ; assert ( palindrom ( slowo ) ) ; } fn test2 ( ) { std :: 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut slowo : String = "Pan"; ; assert ( ! palindrom ( slowo ) ) ; } fn main ( ) { test1 ( ) ; test2 ( ) ; 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 std::process::exit( 0 ); }